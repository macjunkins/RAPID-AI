#!/bin/bash

# Common functions for AI development workflow
# Language-agnostic functionality extracted from EmberCare implementation

# Detect environment
detect_environment() {
    if [ "$TERM_PROGRAM" = "vscode" ]; then
        echo "vscode"
    elif [ -n "$CODESPACES" ]; then
        echo "codespaces"
    else
        echo "terminal"
    fi
}

# Progress indicator with environment awareness
show_progress() {
    local duration=${1:-120}
    local environment=$(detect_environment)
    local elapsed=0
    
    if [ "$environment" = "vscode" ]; then
        # Simple progress for VS Code
        echo "ðŸ¤– AI is analyzing... Please wait..."
        while [ $elapsed -lt $duration ]; do
            if ! kill -0 $AI_PID 2>/dev/null; then
                break
            fi
            echo "â³ Still processing... ($elapsed seconds elapsed)"
            sleep 10
            elapsed=$((elapsed + 10))
        done
    else
        # Animated progress bar for terminals
        local interval=5
        local total_dots=10
        
        while [ $elapsed -lt $duration ]; do
            if ! kill -0 $AI_PID 2>/dev/null; then
                break
            fi
            
            local progress=$((elapsed * 100 / duration))
            local dots=$((progress * total_dots / 100))
            local bar=""
            
            for i in $(seq 1 $total_dots); do
                if [ $i -le $dots ]; then
                    bar="${bar}â–ˆ"
                else
                    bar="${bar} "
                fi
            done
            
            printf "\rðŸ’­ Progress: [%s] %d%%" "$bar" "$progress"
            sleep $interval
            elapsed=$((elapsed + interval))
        done
        echo "" # New line after progress
    fi
}

# Run AI analysis with tool abstraction
run_ai_analysis() {
    local tool=$1
    local prompt=$2
    local output_file=$3
    local timeout=${4:-120}
    
    echo "ðŸ“Š Generating analysis..."
    echo "ðŸ¤– AI is thinking... (this may take 30-60 seconds)"
    
    # Create temp file for output
    local temp_output=$(mktemp)
    
    # Start progress indicator
    show_progress $timeout &
    local progress_pid=$!
    
    # Run AI tool with timeout
    case "$tool" in
        "copilot")
            timeout ${timeout}s copilot -p "$prompt" > "$temp_output" &
            AI_PID=$!
            ;;
        "claude")
            timeout ${timeout}s claude_api_call "$prompt" > "$temp_output" &
            AI_PID=$!
            ;;
        "gpt4")
            timeout ${timeout}s openai_api_call "$prompt" > "$temp_output" &
            AI_PID=$!
            ;;
        *)
            echo "âŒ Unsupported AI tool: $tool"
            exit 1
            ;;
    esac
    
    # Wait for completion
    wait $AI_PID
    local exit_code=$?
    
    # Stop progress indicator
    kill $progress_pid 2>/dev/null || true
    wait $progress_pid 2>/dev/null || true
    
    if [ $exit_code -eq 0 ] && [ -s "$temp_output" ]; then
        # Success - process output
        process_ai_output "$temp_output" "$output_file"
        echo "âœ… Analysis complete"
    else
        # Failure - create fallback
        echo "âš ï¸ AI analysis timed out or failed, creating template..."
        create_fallback_template "$output_file"
        echo "ðŸ“ Fallback template created"
    fi
    
    # Cleanup
    rm -f "$temp_output"
    
    # Auto-open in editor if available
    auto_open_file "$output_file"
}

# Process AI output and add metadata
process_ai_output() {
    local temp_file=$1
    local output_file=$2
    
    # Add metadata header
    cat > "$output_file" << EOF
# Story Discovery - AI Generated

**Generated by:** AI Development Workflow
**Date:** $(date +%Y-%m-%d)
**AI Tool:** $AI_TOOL
**Status:** AI Analysis Complete

---

EOF
    
    # Append AI content
    cat "$temp_file" >> "$output_file"
}

# Create fallback template when AI fails
create_fallback_template() {
    local output_file=$1
    
    cat > "$output_file" << EOF
# Story Discovery - Template

**Generated by:** AI Development Workflow (Fallback Template)
**Date:** $(date +%Y-%m-%d)
**Status:** Manual completion required

---

## Story Summary
[Add story details from requirements]

## Technical Analysis
### Requirements
- [ ] Review functional requirements
- [ ] Identify non-functional requirements
- [ ] Define acceptance criteria

### Architecture Considerations
- [ ] Database changes needed
- [ ] API changes required
- [ ] UI components to build
- [ ] Integration points

### Implementation Plan
1. [ ] Step 1: [Define specific step]
2. [ ] Step 2: [Define specific step]
3. [ ] Step 3: [Define specific step]

### Testing Strategy
- [ ] Unit tests required
- [ ] Integration tests needed
- [ ] E2E testing approach

### Files to Create/Modify
- [ ] \`file1.ext\` - [Purpose]
- [ ] \`file2.ext\` - [Purpose]

## Next Steps
1. Complete the manual analysis above
2. Review with team
3. Begin implementation

---
*This template was created because AI analysis failed or timed out. Please complete manually.*
EOF
}

# Auto-open file in appropriate editor
auto_open_file() {
    local file=$1
    local environment=$(detect_environment)
    
    case "$environment" in
        "vscode")
            if command -v code &> /dev/null; then
                echo "ðŸ“‚ Opening in VS Code..."
                code "$file"
            fi
            ;;
        "codespaces")
            echo "ðŸ“‚ File ready: $file"
            ;;
        *)
            if command -v code &> /dev/null; then
                echo "ðŸ“‚ Opening in VS Code..."
                code "$file"
            elif command -v open &> /dev/null; then
                echo "ðŸ“‚ Opening file..."
                open "$file"
            fi
            ;;
    esac
}

# Post-process discovery document
post_process_discovery() {
    local file=$1
    
    # Add any post-processing logic here
    # For example: validate structure, add links, etc.
    
    echo "ðŸ“ Discovery document ready: $file"
}

# API calls for different AI tools (placeholder implementations)
claude_api_call() {
    local prompt=$1
    # TODO: Implement Claude API integration
    echo "Claude API integration not yet implemented"
    return 1
}

openai_api_call() {
    local prompt=$1
    # TODO: Implement OpenAI API integration
    echo "OpenAI API integration not yet implemented"
    return 1
}

# Load project configuration
load_project_config() {
    if [ -f "$PROJECT_CONFIG" ]; then
        # Load project-specific settings (requires yq for YAML parsing)
        if command -v yq &> /dev/null; then
            PROJECT_TYPE=$(yq eval '.project.type' "$PROJECT_CONFIG" 2>/dev/null || echo "generic")
            AI_TOOL=$(yq eval '.ai_tools[0]' "$PROJECT_CONFIG" 2>/dev/null || echo "$AI_TOOL")
            ARCHITECTURE=$(yq eval '.project.architecture[]' "$PROJECT_CONFIG" 2>/dev/null || echo "")
        else
            # Fallback to basic parsing without yq
            PROJECT_TYPE=$(grep "type:" "$PROJECT_CONFIG" | sed 's/.*type: *"\?\([^"]*\)"\?.*/\1/' || echo "generic")
        fi
    else
        PROJECT_TYPE="generic"
        ARCHITECTURE=""
    fi
}

# Generate AI prompt based on project type
generate_prompt() {
    local epic=$1
    local story=$2
    local title=$3
    local base_prompt="Analyze Epic $epic, Story $story: $title"
    
    case "$PROJECT_TYPE" in
        "flutter")
            echo "$base_prompt. For this Flutter project using BLoC + Drift architecture, provide: 1. Story requirements summary 2. Drift table definitions 3. BLoC events/states 4. UI components 5. Testing approach 6. Implementation files list. Keep response concise and actionable."
            ;;
        "react")
            echo "$base_prompt. For this React project, provide: 1. Component requirements 2. State management approach 3. API integrations 4. Testing strategy 5. Implementation files list."
            ;;
        "python")
            echo "$base_prompt. For this Python project, provide: 1. Requirements analysis 2. Database models 3. API endpoints 4. Testing approach 5. Implementation files list."
            ;;
        *)
            echo "$base_prompt. Provide: 1. Requirements summary 2. Technical approach 3. Implementation plan 4. Testing strategy 5. Files to create/modify."
            ;;
    esac
}